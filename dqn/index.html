<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Race Dashboard (DQN)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root { --gap: 14px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial; margin: 16px; background: #fafafa; }
    h1 { margin: 0 0 12px; }
    .cards { display: grid; grid-template-columns: repeat(6, minmax(140px, 1fr)); gap: var(--gap); margin-bottom: var(--gap); }
    .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 10px 12px; background: #fff; box-shadow: 0 1px 1px rgba(0,0,0,0.03); }
    .value { font-size: 20px; font-weight: 600; }
    .muted { color: #666; font-size: 12px; }
    .pill { display:inline-block; padding:4px 10px; border-radius:999px; border:1px solid #ccc; text-transform: capitalize; font-weight:600; }
    .pill[data-a="0"] { background:#e6ffed; color: #00611a; border-color: #a3e9b6; } /* Accel */
    .pill[data-a="1"] { background:#fff5e6; color: #783a00; border-color: #ffdcb0; } /* Brake */
    .pill[data-a="2"] { background:#eef2ff; color: #3730a3; border-color: #c1c7f7; } /* Coast */
    .pill[data-a="3"] { background:#fef2f2; color: #9a2c2c; border-color: #f7c1c1; } /* Pit */

    .grid { display: grid; grid-template-columns: 2fr 1fr; gap: var(--gap); }
    /* --- NEW: 2x2 Grid for Charts --- */
    .chart-grid { display: grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
    /* --- End New --- */
    canvas { width: 100%; height: 260px; }
    .vstack { display: grid; gap: var(--gap); }
    .progress { width: 100%; height: 8px; background: #f0f0f0; border-radius: 999px; overflow:hidden; margin-top:6px; }
    .bar { height: 100%; width: 0%; background: #3b82f6; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .small { font-size: 12px; }
    /* --- NEW: Style for Lap Progress Text --- */
    #lapProgressText { font-size: 14px; margin-top: 4px; color: #333; }
    /* --- End New --- */
  </style>
</head>
<body>
  <h1>Race Dashboard (DQN)</h1>

  <div class="cards"> 
    <div class="card">
      <div class="muted">Lap Progress</div>
      <div class="value"><span id="progressPct">0</span>%</div>
      <div class="progress"><div class="bar" id="progressBar"></div></div>
    </div>

    <div class="card">
      <div class="muted">Speed (km/h)</div>
      <div class="value"><span id="speed">0.0</span> km/h</div>
    </div>

    <div class="card">
      <div class="muted">Distance to Pit</div>
      <div class="value"><span id="distPit">0.0</span> m</div>
    </div>

    <div class="card">
      <div class="muted">Current / Total Laps</div>
      <div class="value">#<span id="lap">0</span> / <span id="totalLaps">0</span></div>
      <div class="small muted"><span id="lapsRemaining">0</span> laps remaining</div>
    </div>

    <div class="card">
      <div class="muted">Fuel</div>
      <div class="value"><span id="fuelPct">0</span>%</div>
      <div class="small muted">raw: <span id="fuelRaw">0.0</span> L</div>
    </div>

    <div class="card">
      <div class="muted">Recommended Decision</div>
      <div id="decision" class="pill" data-a="2">Coast</div>
    </div>
  </div> 
  <div class="grid">
    <div class="chart-grid">
        <div class="card"><canvas id="speedChart"></canvas></div>
        <div class="card"><canvas id="tireChart"></canvas></div>
        <div class="card"><canvas id="fuelChart"></canvas></div>
        <div class="card">
            <canvas id="trackCanvas"></canvas>
        </div>
    </div>

    <div class="vstack">
      <div class="card"><canvas id="radiiChart"></canvas></div>
      <div class="card">
        <div class="muted">Action ticker (last ~10s)</div>
        <div id="actionTicker" class="row"></div>
      </div>
    </div>
  </div>

<script>
// =====================
// Config & helpers
// !! YOU MUST SET THESE to match your config.py !!
// =====================
const CFG = {
  // --- De-normalization constants (from config.py) ---
  MAX_SPEED_MPH: 200.0,       // MAX_SPEED from config.py
  MAX_FUEL_LITERS: 100.0,     // MAX_FUEL_LITERS from config.py
  TOTAL_LAPS: 20,             // TOTAL_LAPS from config.py
  LAP_DISTANCE_M: 3200.0,     // Should be 1600 * 2.0 based on previous info

  // --- Frontend config ---
  WINDOW_SECONDS: 10,          // time-series window size
  TARGET_HZ: 10,               // expected frame rate
  WS_PATH: `ws://localhost:8000/ws`,
  HISTORY_URL: `http://localhost:8000/history?seconds=10`,
};
// --- End Config ---

const MPS_PER_MPH = 0.44704;
const MAX_POINTS = CFG.WINDOW_SECONDS * CFG.TARGET_HZ - 2;
const MAX_SPEED_MPS = CFG.MAX_SPEED_MPH * MPS_PER_MPH;
const MAX_SPEED_KMH = MAX_SPEED_MPS * 3.6;

const ACTION_MAP = {
  0: { label: 'Accel', badge: 'A', key: '0' },
  1: { label: 'Brake', badge: 'B', key: '1' },
  2: { label: 'Coast', badge: 'C', key: '2' },
  3: { label: 'Pit Stop', badge: 'P', key: '3' },
};
function getActionInfo(actionInt) {
  return ACTION_MAP[actionInt] || { label: `Unknown (${actionInt})`, badge: '?', key: '' };
}

function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
function clamp01(x){ return clamp(x, 0, 1); }
function fmt(n, d=1){ return Number(n).toFixed(d); }

// =====================
// DOM elements
// =====================
const el = {
  progressPct: document.getElementById('progressPct'),
  progressBar: document.getElementById('progressBar'),
  speed: document.getElementById('speed'),
  distPit: document.getElementById('distPit'),
  lap: document.getElementById('lap'),
  totalLaps: document.getElementById('totalLaps'),
  lapsRemaining: document.getElementById('lapsRemaining'),
  fuelPct: document.getElementById('fuelPct'),
  fuelRaw: document.getElementById('fuelRaw'),
  decision: document.getElementById('decision'),
  ticker: document.getElementById('actionTicker'),
};
el.totalLaps.textContent = CFG.TOTAL_LAPS;

// =====================
// Charts (Chart.js)
// =====================
const labels = [];
const speedData = [];
const twFL = [], twFR = [], twRL = [], twRR = [];
const fuelPctData = [];
const r20 = [], r50 = [], r100 = [];

function trimBuffers(){
  const arrays = [labels, speedData, twFL, twFR, twRL, twRR, fuelPctData, r20, r50, r100];
  arrays.forEach(arr => { while(arr.length > MAX_POINTS) arr.shift(); });
}

function makeLine(ctx, title, datasets, yOpts={}){
  return new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      animation: false,
      responsive: true,
      interaction: { mode: 'nearest', intersect: false },
      scales: { x: { display:false }, y: yOpts },
      plugins: { legend: { display: true }, title: { display: true, text: title } }
    }
  });
}

const speedChart = makeLine(
  document.getElementById('speedChart').getContext('2d'),
  'Speed (km/h)',
  [ { label: 'Current Speed (km/h)', data: speedData, borderColor: '#3b82f6', backgroundColor: '#3b82f630', fill: true } ],
  { min: 0, max: MAX_SPEED_KMH, ticks: { callback: (v) => v + ' km/h' } }
);

const tireChart = makeLine(
  document.getElementById('tireChart').getContext('2d'),
  'Tire Wear',
  [
    { label: 'Front Left', data: twFL },
    { label: 'Front Right', data: twFR },
    { label: 'Rear Left', data: twRL },
    { label: 'Rear Right', data: twRR },
  ],
  { min: 0, max: 1, ticks: { callback: (v)=> (v*100) + '%' } }
);

const fuelChart = makeLine(
  document.getElementById('fuelChart').getContext('2d'),
  'Fuel (%)',
  [ { label: 'Fuel (%)', data: fuelPctData } ],
  { min: 0, max: 100, ticks: { callback: (v) => v + '%' } }
);

const radiiChart = makeLine(
  document.getElementById('radiiChart').getContext('2d'),
  'Turn Radius (m)',
  [
    { label: '50 m ahead', data: r20 },
    { label: '100 m ahead', data: r50 },
    { label: '200 m ahead', data: r100 },
  ],
  { type: 'logarithmic', ticks: { callback: (v) => fmt(v,0) + ' m' } }
);

// =====================
// Track Visualization
// =====================
const trackCanvas = document.getElementById('trackCanvas');
trackCanvas.width = trackCanvas.clientWidth;
trackCanvas.height = trackCanvas.clientHeight;
const ctxTrack = trackCanvas.getContext('2d');

let track_data = [];
let trackReady = false;
let trackBounds = null;

// Load track data once at startup
async function loadTrackData() {
  try {
    const res = await fetch('../track_5762.json');
    const data = await res.json();
    track_data = data.visualization_data; 
    
    if (Array.isArray(track_data) && track_data.length > 1) {
      const xs = track_data.map(p => p.x);
      const ys = track_data.map(p => p.y);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      trackBounds = { minX, maxX, minY, maxY };
      trackReady = true;
      drawTrack(0); // Draw initial static track
    } else {
      console.warn("Track data empty or invalid");
    }
  } catch (e) {
    console.error("Failed to load track_data.json", e);
  }
}

function drawTrack(progress) {
  if (!trackReady) return;

  const w = trackCanvas.width = trackCanvas.clientWidth;
  const h = trackCanvas.height = trackCanvas.clientHeight;
  ctxTrack.clearRect(0, 0, w, h);

  const pad = 20; // canvas border

  // Find min/max from track data dynamically
  const xs = track_data.map(p => p.x);
  const ys = track_data.map(p => p.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);

  const trackWidth = maxX - minX;
  const trackHeight = maxY - minY;

  // Normalize scale to fit canvas
  const scale = Math.min((w - 2*pad) / trackWidth, (h - 2*pad) / trackHeight);

  // Function to map real track coordinates to canvas
  const sx = x => pad + (x - minX) * scale;
  const sy = y => h - pad - (y - minY) * scale; // invert y-axis for canvas

  // Draw track
  ctxTrack.beginPath();
  ctxTrack.lineWidth = 2;
  ctxTrack.strokeStyle = '#999';
  ctxTrack.moveTo(sx(track_data[0].x), sy(track_data[0].y));
  for (const p of track_data) ctxTrack.lineTo(sx(p.x), sy(p.y));
  ctxTrack.stroke();

  // Draw car
  const idx = progress * (track_data.length - 1);
  const low = Math.floor(idx);
  const high = Math.min(track_data.length - 1, low + 1);
  const ratio = idx - low;
  const x = track_data[low].x + ratio * (track_data[high].x - track_data[low].x);
  const y = track_data[low].y + ratio * (track_data[high].y - track_data[low].y);

  ctxTrack.beginPath();
  ctxTrack.fillStyle = '#3b82f6';
  ctxTrack.arc(sx(x), sy(y), 6, 0, Math.PI * 2);
  ctxTrack.fill();
}

// Load data immediately
loadTrackData();

// =====================
// Action ticker
// =====================
function pushActionTick(actionInfo){
  const dot = document.createElement('span');
  dot.className = 'pill';
  dot.dataset.a = actionInfo.key;
  dot.textContent = actionInfo.badge;
  dot.title = actionInfo.label;
  el.ticker.appendChild(dot);
  while(el.ticker.children.length > MAX_POINTS) el.ticker.removeChild(el.ticker.firstChild);
}

// =====================
// Networking: backfill + live WS
// =====================
async function backfill(){
  try{
    const res = await fetch(CFG.HISTORY_URL, { mode: 'cors' });
    if(!res.ok) return;
    const frames = await res.json();
    frames.sort((a,b)=>a.ts-b.ts).forEach(applyFrame);
  }catch(e){ console.warn('backfill error', e); }
}

let ws = null; let wsTimer = null;
function connect(){
  const url = CFG.WS_PATH;
  ws = new WebSocket(url);
  ws.onopen = ()=>{ if(wsTimer){ clearTimeout(wsTimer); wsTimer=null; } console.log('[ws] open', url); };
  ws.onmessage = (e)=>{ const fr = JSON.parse(e.data); applyFrame(fr); };
  ws.onerror = (e)=>{ console.error('[ws] error', e); };
  ws.onclose = (e)=>{ console.warn('[ws] closed', e.code, e.reason); wsTimer = setTimeout(connect, 500); };
}

// =============================================
// == CORE DATA MAPPING: Apply Frame (UPDATED)
// =============================================
function applyFrame(fr){
  // Contract check
  if(!fr || !fr.state || !fr.state.state_vector || fr.decision == null || fr.distance_on_lap == null) return;

  const s = fr.state.state_vector;
  const t = fr.ts;
  const label = new Date(t * 1000).toLocaleTimeString();

  // --- De-normalize data ---
  const current_speed_mps = s[0] * MAX_SPEED_MPS;
  const current_speed_kmh = current_speed_mps * 3.6;
  const fuel_pct_01 = s[1];
  const tire_fl = s[2];
  const tire_fr = s[3];
  const tire_rl = s[4];
  const tire_rr = s[5];
  const laps_remaining = Math.round(s[6] * CFG.TOTAL_LAPS);
  const dist_to_pit = s[7] * CFG.LAP_DISTANCE_M;
  const radius_20m = Math.expm1(s[8]);
  const radius_50m = Math.expm1(s[9]);
  const radius_100m = Math.expm1(s[10]);

  const distance_on_lap = fr.distance_on_lap;
  const current_lap_num = fr.lap ?? '—';

  // --- Update KPIs ---
  el.speed.textContent = fmt(current_speed_kmh);
  el.distPit.textContent = fmt(dist_to_pit);
  el.lap.textContent = current_lap_num;
  el.lapsRemaining.textContent = laps_remaining;

  const fuelPct100 = clamp01(fuel_pct_01) * 100;
  el.fuelPct.textContent = fmt(fuelPct100, 0);
  el.fuelRaw.textContent = fmt(fuel_pct_01 * CFG.MAX_FUEL_LITERS);

  // --- Update Decision Pill + Ticker ---
  const actionInt = fr.decision.action;
  const actionInfo = getActionInfo(actionInt);
  el.decision.dataset.a = actionInfo.key;
  el.decision.textContent = actionInfo.label;
  pushActionTick(actionInfo);

  // --- Update Time-series Buffers ---
  labels.push(label);
  speedData.push(current_speed_kmh);
  twFL.push(tire_fl); twFR.push(tire_fr); twRL.push(tire_rl); twRR.push(tire_rr);
  fuelPctData.push(fuelPct100);
  r20.push(radius_20m); r50.push(radius_50m); r100.push(radius_100m);
  trimBuffers();

  // --- Update Charts ---
  speedChart.update('none');
  tireChart.update('none');
  fuelChart.update('none');
  radiiChart.update('none');

  // --- Update Progress Bar & Percentage ---
  if(CFG.LAP_DISTANCE_M > 0){
    const pct = Math.max(0, Math.min(100, (distance_on_lap / CFG.LAP_DISTANCE_M) * 100));
    el.progressBar.style.width = `${pct}%`;
    el.progressPct.textContent = fmt(pct, 0); // Update the percentage display
    drawTrack(pct / 100);
  } else {
    el.progressBar.style.width = '0%';
    el.progressPct.textContent = '—'; // Show placeholder if no lap distance
  }
}

// Boot
backfill().then(connect);
</script>
</body>
</html>